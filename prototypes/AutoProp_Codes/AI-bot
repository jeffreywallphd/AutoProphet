

# Importing libraries
import spacy
import yfinance as yf
import dateparser
import re
import torch
import matplotlib.pyplot as plt
import pandas as pd
from datetime import datetime, timedelta
from transformers import BertTokenizer, BertForSequenceClassification


# Load spaCy model for date extraction
nlp = spacy.load("en_core_web_sm")

# Function to extract dates and time periods from queries
def extract_dates(query):
    query_lower = query.lower()
    regex_patterns = {
        "last week": "5d",
        "this week": "5d",
        "last month": "1mo",
        "this month": "1mo",
        "last year": "1y",
        "this year": "ytd",
        "year to date": "ytd",
        "three months": "3mo",
        "six months": "6mo",
        r"\d+ days? ago": "custom_days",
        r"\d+ weeks? ago": "custom_weeks",
        r"\d+ months? ago": "custom_months"
    }

    for pattern, period in regex_patterns.items():
        if re.search(pattern, query_lower):
            if period == "custom_days":
                days_ago = int(re.search(r"\d+", query_lower).group())
                return datetime.now() - timedelta(days=days_ago), None
            elif period == "custom_weeks":
                weeks_ago = int(re.search(r"\d+", query_lower).group())
                return datetime.now() - timedelta(weeks=weeks_ago), None
            elif period == "custom_months":
                months_ago = int(re.search(r"\d+", query_lower).group())
                return datetime.now() - timedelta(days=months_ago * 30), None
            return None, period

    doc = nlp(query)
    for ent in doc.ents:
        if ent.label_ == "DATE":
            return dateparser.parse(ent.text), None
    return dateparser.parse(query), None

# Known stock symbols for direct matching
known_symbols = ["TSLA", "AMZN", "MSFT", "GOOGL", "META", "AAPL", "AMD", "NVDA"]

# Function to extract company names or symbols
def extract_company_names(query):
    doc = nlp(query)
    companies = [ent.text for ent in doc.ents if ent.label_ == "ORG"]

    manual_corrections = {
        "Tesla": "TSLA",
        "Amazon": "AMZN",
        "Microsoft": "MSFT",
        "Google": "GOOGL",
        "Facebook": "META",
        "Apple": "AAPL"
    }

    detected_symbols = [word.upper() for word in query.split() if word.upper() in known_symbols]
    corrected_companies = [manual_corrections.get(company, company) for company in companies]
    return list(set(detected_symbols + corrected_companies))

# Function to predict class labels with confidence threshold
def predict_class(query, model, tokenizer, label_map, threshold=0.5):
    inputs = tokenizer(query, return_tensors="pt", padding=True, truncation=True)
    with torch.no_grad():
        outputs = model(**inputs)
    probs = torch.nn.functional.softmax(outputs.logits, dim=1)
    confidence, predicted_class = torch.max(probs, dim=1)
    if confidence.item() < threshold:
        print("Low confidence in prediction. Consider rephrasing the query.")
        return None
    return label_map.get(predicted_class.item(), None)

# Function to generate a trend summary
def generate_trend_summary(data, price_type, start_date, end_date):
    start_value = data.iloc[0]
    end_value = data.iloc[-1]
    percentage_change = ((end_value - start_value) / start_value) * 100

    if end_value > start_value:
        trend = "upward"
    elif end_value < start_value:
        trend = "downward"
    else:
        trend = "stable"

    return (f"The plot shows a {trend} trend from {start_date.strftime('%B %d, %Y')} to "
            f"{end_date.strftime('%B %d, %Y')} with a percentage change of {percentage_change:.2f}%.")

# Function to fetch stock data with error handling and specific date handling
def fetch_stock_data(stock_symbol, price_type, time_period=None, specific_date=None, for_trend=False):
    try:
        stock = yf.Ticker(stock_symbol)
        market_closed_message = ""

        if specific_date:
            original_date = specific_date
            start_date = specific_date
            end_date = specific_date + timedelta(days=1)
            historical_data = stock.history(start=start_date, end=end_date)

            while historical_data.empty and start_date > datetime(2000, 1, 1):
                start_date -= timedelta(days=1)
                end_date = start_date + timedelta(days=1)
                historical_data = stock.history(start=start_date, end=end_date)

            if start_date != original_date:
                market_closed_message = f"The market was closed on {original_date.strftime('%B %d, %Y')}. Displaying data from the nearest available trading day: {start_date.strftime('%B %d, %Y')}."

            if historical_data.empty:
                print(f"Error: No data found for {stock_symbol} on {specific_date}. Try a different date or time period.")
                return None

        else:
            historical_data = stock.history(period=time_period)

        if historical_data.empty:
            print(f"Error: No data found for {stock_symbol} on {specific_date or time_period}. Try a different date or time period.")
            return None

        if market_closed_message:
            print(market_closed_message)

        if for_trend:
            return historical_data[price_type.capitalize()] if price_type in ['open', 'close', 'high', 'low', 'volume'] else historical_data['Close']

        if price_type == "volume" and not specific_date:
            return historical_data['Volume'].mean()
        else:
            price_lookup = {
                "high": historical_data['High'].max,
                "low": historical_data['Low'].min,
                "open": lambda: historical_data['Open'].iloc[0],
                "close": lambda: historical_data['Close'].iloc[-1],
                "volume": lambda: historical_data['Volume'].iloc[-1] if specific_date else historical_data['Volume'].sum,
                "current": lambda: historical_data['Close'].iloc[-1]
            }

            return price_lookup[price_type]() if not historical_data.empty else None

    except Exception as e:
        print(f"An error occurred: {e}")
        return None

# Add the other required functions (plotting functions, main query handler, etc.)

# Visualization functions
def plot_comparison(stock_data, stock_symbols, price_type, time_period):
    plt.figure(figsize=(10, 6))
    plt.bar(stock_symbols, stock_data)
    plt.title(f"Comparison of {price_type.capitalize()} Prices for {' and '.join(stock_symbols)}")
    plt.ylabel(f"{price_type.capitalize()} Price")
    plt.xlabel("Stocks")
    plt.show()

def plot_multiple_trends(stock_data_dict, price_type, time_period):
    main_title = f" Stock Price Movements over the period of {time_period.capitalize()}" if len(stock_data_dict) > 1 else f"{list(stock_data_dict.keys())[0]} Stock Price Movement ({time_period.capitalize()} Trend)"

    fig, axes = plt.subplots(len(stock_data_dict), 1, figsize=(10, 6 * len(stock_data_dict)), sharex=True)
    fig.suptitle(main_title, fontsize=16)

    if len(stock_data_dict) == 1:
        axes = [axes]

    for i, (symbol, data) in enumerate(stock_data_dict.items()):
        start_date = data.index[0]
        end_date = data.index[-1]
        axes[i].plot(data, label=f"{symbol} Price", color='tab:blue')
        axes[i].set_title(f"{symbol} Trend from {start_date.strftime('%B %d, %Y')} to {end_date.strftime('%B %d, %Y')}")
        axes[i].set_ylabel(f"{price_type.capitalize()} Price")
        axes[i].legend(loc="best")
        axes[i].grid(axis='y', linestyle='--', linewidth=0.5)
        trend_summary = generate_trend_summary(data, price_type, start_date, end_date)
        print(f"Summary for {symbol}: {trend_summary}")

    plt.tight_layout(rect=[0, 0, 1, 0.96])
    plt.show()

def fetch_stock_summary(stock_symbol):
    stock = yf.Ticker(stock_symbol)
    info = stock.info
    return {
        "Name": info.get("shortName"),
        "Market Cap": info.get("marketCap"),
        "Sector": info.get("sector"),
        "Industry": info.get("industry"),
        "Country": info.get("country"),
        "Previous Close": info.get("previousClose"),
        "52 Week Range": (info.get("fiftyTwoWeekLow"), info.get("fiftyTwoWeekHigh")),
        "Open": info.get("open"),
        "Volume": info.get("volume"),
        "Avg Volume": info.get("averageVolume"),
        "Beta (5Y Monthly)": info.get("beta"),
        "PE Ratio (TTM)": info.get("trailingPE"),
        "EPS (TTM)": info.get("trailingEps"),
        "1y Target Est": info.get("targetMeanPrice")
    }
# Main query handling function
def handle_query(query):
    specific_date, time_period = extract_dates(query)
    company_names = extract_company_names(query)

    if company_names:
        stock_symbols = [company for company in company_names if company in known_symbols]

        if stock_symbols:
            #print(f"Question: {query}")

            # Special handling for summaries
            if "summary" in query.lower() or "52 week range" in query.lower():
                for symbol in stock_symbols:
                    summary = fetch_stock_summary(symbol)
                    print(f"Answer: Summary for {symbol}: {summary}")
                return

            # Load models only once to avoid reloading per query
            intent_model = BertForSequenceClassification.from_pretrained("./fine_tuned_intent_model1")
            intent_tokenizer = BertTokenizer.from_pretrained("./fine_tuned_intent_model1")
            price_model = BertForSequenceClassification.from_pretrained("./fine_tuned_price_type_model")
            price_tokenizer = BertTokenizer.from_pretrained("./fine_tuned_price_type_model")
            time_model = BertForSequenceClassification.from_pretrained("./fine_tuned_time_period_model")
            time_tokenizer = BertTokenizer.from_pretrained("./fine_tuned_time_period_model")

            # Map intents, price types, and time periods
            intent_labels = {0: 'price_inquiry', 1: 'stock_comparison', 2: 'stock_trend', 3: 'summary'}
            price_labels = {0: 'low', 1: 'open', 2: 'high', 3: 'close', 4: 'volume', 5: 'current'}
            time_labels = {0: '3mo', 1: '1d', 2: '2d', 3: '1mo', 4: '6mo', 5: '5d', 6: '1y', 7: 'ytd'}

            # Predict intent, price type, and time period
            predicted_intent = predict_class(query, intent_model, intent_tokenizer, intent_labels)
            predicted_price_type = predict_class(query, price_model, price_tokenizer, price_labels)
            predicted_time_period = time_period or predict_class(query, time_model, time_tokenizer, time_labels)

            # Handle specific date queries as price_inquiry for volume and prices
            if predicted_intent == "price_inquiry" or (predicted_intent == "stock_trend" and specific_date):
                for symbol in stock_symbols:
                    stock_data = fetch_stock_data(symbol, predicted_price_type, time_period=predicted_time_period, specific_date=specific_date)
                    if stock_data is not None:
                        date_display = specific_date.strftime('%B %d, %Y') if specific_date else "the specified period"
                        print(f"Answer: The {predicted_price_type} of {symbol} on {date_display} is {stock_data}.")
                    else:
                        print(f"Answer: No data available for {symbol} on {date_display}.")
                return

            # Handle stock trend without a specific date
            elif predicted_intent == "stock_trend" and not specific_date:
                stock_data_dict = {}
                for symbol in stock_symbols:
                    stock_data = fetch_stock_data(symbol, predicted_price_type, time_period=predicted_time_period, for_trend=True)
                    if stock_data is not None:
                        stock_data_dict[symbol] = stock_data
                    else:
                        print(f"Answer: No trend data available for {symbol}.")

                if stock_data_dict:
                    plot_multiple_trends(stock_data_dict, predicted_price_type, predicted_time_period)
                return

            # Handle stock comparison
            elif predicted_intent == "stock_comparison":
                stock_prices = []
                for symbol in stock_symbols:
                    stock_data = fetch_stock_data(symbol, predicted_price_type, time_period=predicted_time_period)
                    if stock_data is not None:
                        print(f"Answer: The {predicted_price_type} price of {symbol} over the specified period is {stock_data}.")
                        stock_prices.append(stock_data)
                    else:
                        stock_prices.append(None)
                        print(f"Answer: No data available for {symbol} during the specified period.")

                # Ask if the user wants a comparison plot when multiple stocks are involved
                if len(stock_symbols) > 1 and any(stock_prices):
                    visualize_input = input("Would you like to see a comparison plot? (Yes/No): ").strip().lower()
                    if visualize_input == "yes":
                        valid_prices = [price for price in stock_prices if price is not None]
                        valid_symbols = [symbol for symbol, price in zip(stock_symbols, stock_prices) if price is not None]
                        if valid_prices and valid_symbols:
                            plot_comparison(valid_prices, valid_symbols, predicted_price_type)
                        else:
                            print("Answer: Insufficient data to generate a comparison plot.")
                return

            # Handle summary
            elif predicted_intent == "summary":
                for symbol in stock_symbols:
                    summary = fetch_stock_summary(symbol)
                    print(f"Answer: Summary for {symbol}: {summary}")

            else:
                print(f"Answer: Unable to handle the intent '{predicted_intent}' for the query.")

        else:
            print("Answer: Could not find valid stock symbols in the query.")
    else:
        print("Answer: No company names detected in the query.")


# Run the query loop
while True:
    user_query = input("Ask a question (or type 'exit' to quit): ")
    if user_query.lower() == 'exit':
        break
    handle_query(user_query)
